from django.db import models
from django.http import HttpResponseServerError
from django.core.exceptions import ValidationError
from typing import Type

from uuid import uuid4


class BaseModel(models.Model):

    class Meta:
        abstract = True


class WideModel(BaseModel):
    autogenerated_slug = True
    _loaded_state = None
    uneditable_validated_fields = list()

    def __validate_uneditabe_fields(self) -> None:
        if not self.is_adding():
            for field_name in self.uneditable_validated_fields:
                state_field_name = field_name if field_name in self._loaded_state else field_name + "_id"

                if not getattr(self,  state_field_name) == self.get_field_from_loaded_state(state_field_name):
                    raise ValidationError(
                        "Field \"{}\" is uneditable.".format(field_name.capitalize()))

    def clean(self) -> None:
        self.__validate_uneditabe_fields()

    def save(self, *args, **kwargs) -> None:
        if self.autogenerated_slug and self.is_adding():
            self.slug = self.get_unique_slug()

        super().save(*args, **kwargs)

    @ classmethod
    def get_unique_slug(cls, slug_size: int = 10, slug_adder_size: int = 2) -> str:

        unique_slug = cls.generate_random_slug(slug_size)
        counter = 0

        while cls.objects.filter(slug=unique_slug).exists():
            unique_slug = unique_slug + \
                cls.generate_random_slug(slug_adder_size)
            counter += 1

        return unique_slug

    @ staticmethod
    def generate_random_slug(size: int) -> str:
        return str(uuid4()).replace('-', '').lower()[:size]

    def is_adding(self) -> bool:
        return self._state.adding

    @ classmethod
    def from_db(cls, db, field_names, values):
        if len(values) != len(cls._meta.concrete_fields):
            values = list(values)
            values.reverse()
            values = [
                values.pop() if f.attname in field_names else models.DEFERRED
                for f in cls._meta.concrete_fields
            ]
        instance = cls(*values)
        instance._state.adding = False
        instance._state.db = db
        instance._loaded_state = cls.zip_fields_of_instance(
            field_names, values)
        return instance

    @ staticmethod
    def zip_fields_of_instance(field_names, values) -> dict:
        return dict(zip(field_names, (value for value in values if value is not models.DEFERRED)))

    def get_field_from_loaded_state(self, field_name: str) -> object | None:
        field_value = None

        if not self.is_adding():
            field_value = self._loaded_state.get(field_name, None)

        return field_value

    class Meta:
        abstract = True


class BaseLog(models.Model):

    class Meta:
        abstract = True
